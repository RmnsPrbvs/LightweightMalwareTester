from tkinter import *
from tkinter import filedialog
from tkinter import ttk

import pefile
import os
import sys
import subprocess
import binascii
import re
import vt
import hashlib

#---------------------- Initiated Global Variables  -------------------------
# The main global variables that will be manipulated by the functions. 

sha256er = hashlib.sha256()
hex_arra = []
clean_arra = []
filename = ''
storedfi = ''

# Virus total Client API Key, will need to be replaced by any new user
client = vt.Client('b92f21c6072fcf52cf398e7c9234135ec6237f5c48211abfa1625584a32c96c0')

hazsh = ''
tetter = False

# The blacklist of malicious function calls, Is used to compare with the extracted functions to find any redflags in the examined file.
blaklist = ['OpenProcess', 'VirtualAllocEx', 'WriteProcessMemory', 'CreateRemoteThread', 'CloseHandle', 'ShellExecuteA', 'ShellExecuteEx'
            ,'SHCreateDirectoryExW', 'SHChangeNotify', 'DoEnvironmentSubstA', 'EmptyClipboard','GetClipboardSequenceNumber','AllowSetForegroundWindow'
            ,'CallNextHookEx','ChangeDisplaySettingsA','CloseClipboard','DdeFreeDataHandle','DdeNameService','DeregisterShellHookWindow'
            ,'VkKeyScanA','UnregisterHotKey','UnhookWindowsHookEx','SetWindowsHookExW','SetClipboardData','RegisterShellHookWindow'
            ,'RegisterHotKey','RegisterDeviceNotificationA','RegisterClipboardFormatW','RegisterClipboardFormatA','OpenClipboard','MonitorFromRect'
            ,'MonitorFromPoint','MapVirtualKeyW','IsClipboardFormatAvailable','GetWindowThreadProcessId','GetWindowModuleFileName','GetMonitorInfoW'
            ,'GetCurrentThreadWindows','GetKeyboardState','GetKeyState','GetClipboardData','GetClassLongW','EnumWindows','EnumThreadWindows','EnumDesktopsA'
            ,'EnumChildWindows','GetCurrentThreadId','set_UseShellExecute','VirtualProtect','TerminateProcess','RaiseException','21 (setsockopt)','17 (recvfrom)'
            ,'20 (sendto)','23 (socket)','115 (WSAStartup)','116 (WSACleanup)','2 (bind)','9 (htons)','RegDeleteValueA','RegSetValueExW'
            ,'RegEnumKeyW','RegDeleteKeyW','RegSetValueExA','WinHelpA','SHChangeNotify','ShellExecuteExA','GetExitCodeProcess','CryptMsgGetParam'
            ,'CertFreeCTLContext','CertGetStoreProperty','CertGetNameStringA','CertFindCTLInStore','CertDeleteCTLFromStore','CertAlgIdToOID'
            ,'CertCloseStore','MD5Init','MD5Update','MD5Final','RegEnumKeyA','CreateServiceA','RegSaveKeyA','LogonUserW','RegLoadKeyW','RegRestoreKeyW'
            ,'RegUnLoadKeyW','CryptSignHashA','ReadEventLogW','OpenEventLogW','RegDeleteValueW','CreateDesktopA','GetClassLongA','WriteFile','GetLogicalDriveStringsA'
            ,'SleepEx','GetConsoleAliasA','connect','DownloadFile','SHGetFolderPathA']


#---------------------- Hash Generator -------------------------
# The Main Function that will generate the file hash using the hashlib library
# storing the results in the global variables created earlier

def hazsher():
    global hazsh
    global sha256er
    sha256er = hashlib.sha256()
    
    with open(filename, 'rb') as f:
        for byters in iter(lambda: f.read(4096), b''):
            sha256er.update(byters)
        hazsh = sha256er.hexdigest()


#---------------------- Virus Total -------------------------
# Using the Virus Total api, if the user chooses to the program will open a new window
# that will contain all virus total results regarding the file, displaying the name of the antivirus its status and resutl
# the program will also count each case of malicious rating to give a total score

def fullverus():
    veros = Tk()
    
    veros.title("Virus Total")

    veros.grid_columnconfigure(0, weight=1)
    veros.grid_rowconfigure(0, weight=1)
    
    text2 = Text(veros, width='80', height="50")
    text2.grid(row=0, column=0)

    scrollbar = ttk.Scrollbar(veros, orient='vertical', command=text2.yview)
    scrollbar.grid(row=0, column=1, sticky='ns')

    old_stdout = sys.stdout    
    sys.stdout = Redirect(text2)

    tg = 0
    tq = 0
    
    file = client.get_object("/files/" + hazsh)
    zeee = file.last_analysis_results

    print('Virus Total viewer:', filename)
    for zq, zd in zeee.items():
            tg += 1
            print('\nAntiVirus:', zq)
            print('Catagory: ', zd['category'])
            print('Result: ', zd['result'])
            if zd['category'] == 'malicious':
                tq += 1
    print("====")
    print('malicious: ' , tq , '/' , tg)
    text2['yscrollcommand'] = scrollbar.set

#---------------------- Virus Total 2.0 -------------------------
# The main Virus total Display, Counting all malicious warngings found by virus total
# Displaying the results on the main result page, whilst calculating the Final Verdict Score, taking into consideration any false positives.
# and giving the user the option to view a more detailed Virus total Report.

def verus():
    global hazsh
    global client
    global malco

    label_filerz = Label(quickgui, text = "Virus Total: ", width="50", bg="#003e94", fg="white")
    label_filerz.pack(fill='x')

    tg = 0
    tq = 0

    try:

        
        file = client.get_object("/files/" + hazsh)
        zeee = file.last_analysis_results

        for zq, zd in zeee.items():
            tg += 1
            if zd['category'] == 'malicious':
                tq += 1
        
        if tq >= 1 and tq <= 10:
            texter = Text(quickgui, width='90', height="1", bg='#f6b26b')
            texter.pack()
            malco += 1
        elif tq >= 10:
            texter = Text(quickgui, width='90', height="1", bg='#ffb6c1')
            texter.pack()
            malco += 3
        else:
            texter = Text(quickgui, width='90', height="1")
            texter.pack()
            

        old_stdout = sys.stdout    
        sys.stdout = Redirect(texter)

        print('malicious: ' , tq , '/' , tg)

        fullist = Button(quickgui, text = "Expand List", width="50", bg="#003e94", fg="white", command=fullverus).pack(fill='x')
    except:

        texter = Text(quickgui, width='90', height="1")
        texter.pack()
        
        old_stdout = sys.stdout    
        sys.stdout = Redirect(texter)
        
        print('file is not found on virustotal')
    

#---------------------- Binary Converter Lite -------------------------

def qucker(file):
    string = ''
    # calls global arrays to store the values for later use
    global hex_arra
    global clean_arra

    # if any values are already found inside, they are cleared
    clean_arra.clear()
    hex_arra.clear()
    yt = 0
    # a blacklist of special characters that will be skipped over
    bluelist = ["\a", "\b", "\f", "\n", "\r", "\t", "\v", "\x00"]

    # The Lite binary converter, reads the first two lines of the file to generate a quicker result than the main converter
    # Examining each byte and cleaning it to store inside a new list of hex values
    with open(file, 'rb') as f:
        lz = 0
        for line in f.readlines():
            if lz != 2: 
                for byte in line:
                    hex_byte = hex(byte).replace("x","").upper()
                    if byte >= 16:
                        hex_byte = hex_byte.lstrip("0")

                    
                    hex_arra.append(hex_byte)
            else:
                break
    

        # for every hex array item, the program will try and corrolate an ASCII character, if not possible will replace it with a "."
        for zel in hex_arra:

            bytter = bytes.fromhex(zel)

            try:
                ascii_object = bytter.decode('ascii')
            except UnicodeDecodeError:
                ascii_object = '.'

            if ascii_object in bluelist:
                ascii_object = '.'

            clean_arra.append(ascii_object)

#---------------------- Binary Converter -------------------------
# The main binary converter, reads the entire file as bytes,
# Examining each byte and cleaning it to store inside a new list of hex values
# skipping past any special characters and translating if possible the hex values into ASCII

def Hexor(file):
    string = ''
    global hex_arra
    global clean_arra
    clean_arra.clear()
    hex_arra.clear()
    bluelist = ["\a", "\b", "\f", "\n", "\r", "\t", "\v", "\x00"]
    
    with open(file, 'rb') as f:
        lz = 0
        for line in f.readlines():
            for byte in line:
                
                hex_byte = hex(byte).replace("x","").upper()
                if byte >= 16:
                    hex_byte = hex_byte.lstrip("0")

                    
                hex_arra.append(hex_byte)
    
            
        for zel in hex_arra:

            bytter = bytes.fromhex(zel)

            try:
                ascii_object = bytter.decode('ascii')
            except UnicodeDecodeError:
                ascii_object = '.'

            if ascii_object in bluelist:
                ascii_object = '.'

            clean_arra.append(ascii_object)


        

#---------------------- Find File -------------------------
# The function that is called when the user wishes to select a file,
# Global variables are called and overwritten when the user choses a new file type using the Tkinter file dialog option.

def browseFiles():
    global filename
    global storedfi
    global raw
    global malco
    firs = []
    
    filename = filedialog.askopenfilename(initialdir = "/", title = "Select a File", filetypes = (("Text files", "*.txt*"), ("all files", "*.*")))
    firs = filename.split("/")
    storedfi = firs[-1]
    hazsher()
    label_filer.configure(text='Selected File: ' + storedfi, bg="#003e94")
    
    
    
    
#---------------------- Redirect -------------------------
# A new class is created that allows terminal output to be redirected into text boxes in Tkinter.

class Redirect():
    
    def __init__(self, widget):
        self.widget = widget

    def write(self, text):
        self.widget.insert('end', text)

#---------------------- Main Gui -------------------------
# The Main Function that initiates a new window that initiates the starting window allowing the user to choose a file and begin testing.

#initiate the main gui
def main_Gui():
    #link global variables
    global mains1
    global label_filer

    #initiate the main tk window with the correct labels and entries
    mains1 = Tk()
    mains1.configure(background="white")
    mains1.title("Malware Analysis")

    Label(text = "Lightweight Malware Analysis", width="50", height="3", bg="#003e94", font="Verdana 11 underline", fg="white").pack(fill='x')

    From = Label( mains1, text = "1. Choose a file ", width="50")
    From.pack(fill='x')
    
    
    #Informs the user of the chosen file and allows them to chose a new file/begin testing.
    
    label_filer = Label(text = "Selected file:", width="50", bg="#ff0000", fg="white")
    label_filer.pack(fill='x')

    
    filerselector = Button(text = "Choose file", width="50",height="2", bg="#003e94", fg="white", command=browseFiles).pack(fill='x')
    
    Label(text = "2. Start File Analysis", width="50").pack(fill='x')
    start = Button(text = "Begin Scan", width="50", height="2", bg="#003e94", fg="white", command=quscan).pack(fill='x')    

    mains1.mainloop()


#---------------------- Begin Scan Function -------------------------
# The Function that initiates a new window that initiates all tests, to then display to the user as a results page.

def quscan():
    global pe
    global quickgui
    global tetter
    global raw
    global malco
    global blacklist
    global greylist

    #the file is parsed through the qucker function to gather the initial results for the binary analysis and the final verdict score is initiated/reset
    qucker(filename)
    quickgui = Tk()
    malco = 0

    
    #---------------------- PE File -------------------------
    # The initial try statement which examines if the selected file is an executable
    try:
        pe = pefile.PE(filename)
        tetter = pe.is_exe()
        raw = pe.write()
    except:
        pass
        Tetter = False


    #a grey lost that will be used to store any blaclisted libraries found during the PE info section.
    greylist = {}

    
    #---------------------- Initiate Result text -------------------------
    # Calls for a new label to inform the user what file is being analyzed
    quickgui.title("Quick Scan")
    label_filer = Label(quickgui, text = "Selected file: " + storedfi, width="50", bg="#003e94", fg="white")
    label_filer.pack(fill='x')


    
    #---------------------- Entropy -------------------------
    # The main Function that initiates a new window displaying the full list of blacklisted functions found when analyzing the file
    # if the file is an executable then the program will begin calculating entropy by using the entropy function built into PEfile
    if tetter == True:
        label_filer2 = Label(quickgui, text = "File Entropy: ", width="50", bg="#003e94", fg="white")
        label_filer2.pack(fill='x')

        zent = pe.sections[0].entropy_H(raw)
        #Initiates an if statement to record if the entropy is outside the acceptible range, adding onto the final verdict score and changing the colour of the text box
        if zent >= 7 or zent <= 5.2:
            tent = Text(quickgui, width='90', height="1", bg='#ffb6c1')
            tent.pack()
            old_stdout = sys.stdout    
            sys.stdout = Redirect(tent)
            malco += 1
    
            print(zent)

        else:
            tent = Text(quickgui, width='90', height="1")
            tent.pack()
            old_stdout = sys.stdout    
            sys.stdout = Redirect(tent)
    
            print(zent)


    #---------------------- Binary -------------------------
    # Displays a basic Binary preview by printing the first 32 bits and their corresponding ASCII characters
    label_filer3 = Label(quickgui, text = "Binary Preview", width="50", bg="#003e94", fg="white")
    label_filer3.pack(fill='x')

    if True:
        text = Text(quickgui, width='90', height="2")
        text.pack()
        old_stdout = sys.stdout    
        sys.stdout = Redirect(text)
    
        for i in range(0, 32, 16):
            print( *hex_arra[i:i+16], ' | ', *clean_arra[i:i+16])

    #Allowing the user to call a new function to view the full binary, in order to save time and resources during the initial scan

    start = Button(quickgui, text = "View Full Binary", width="50", bg="#003e94", fg="white", command=binvie).pack(fill='x')


    #---------------------- Virus Total -------------------------
    # Retrieves the hash of the file to display in the results page, whilst initiating the VirusTotal Function
    label_filer4 = Label(quickgui, text = "hash 256: " , width="50", bg="#003e94", fg="white")
    label_filer4.pack(fill='x')


    text = Text(quickgui, width='90', height="1")
    text.pack()
    text.insert('end', hazsh)


    #The Virus total Function is Called here, it will then display any results in the quickgui

    verus()

    

    
    #---------------------- PE info -------------------------
    # Generates the next segment of the results page which displays the functions and modules the file requests
    label_filer5 = Label(quickgui, text = "Requested Modules: ", width="50", bg="#003e94", fg="white")
    label_filer5.pack(fill='x')

    if tetter == True:

        # The file extracts Libraires and function calls from the PE report, couting each time a function is found in the blacklist.
        sh = 0
        sa = 0
        tez = Text(quickgui, width='90', height="10")
        tez.pack()
        old_stdout = sys.stdout    
        sys.stdout = Redirect(tez)
        for entry in pe.DIRECTORY_ENTRY_IMPORT:
            print(entry.dll.decode('ascii'))
            sh += 1
            for imp in entry.imports:
                try:
                    print('\t', imp.name.decode('ascii'))
                    mana = imp.name.decode('ascii')
                except:
                    mana = imp.name
                    print('\t', imp.name)
                
                if mana in blaklist:
                    sa += 1
                    if entry.dll.decode('ascii') not in greylist:
                        greylist[entry.dll.decode('ascii')] = []
                        greylist[entry.dll.decode('ascii')].append(mana)
                    else:
                        greylist[entry.dll.decode('ascii')].append(mana)


        # the calculation regarding the final verdict score, if there are too many blacklisted functions, then the file is given a higher score
        #but if there is only one library requested, then it is also marked as a high score, due to it denoting something being hidden
        if sa > 4:
            malco += 2
            tez.config(bg="#ffb6c1")
            dist = Button(quickgui, text = "View Blacklisted Libraries", width="50", bg="#003e94", fg="white", command=blaview).pack(fill='x')
        elif sa >= 1:
            malco += 1
            tez.config(bg="#f6b26b")
            dist = Button(quickgui, text = "View Blacklisted Libraries", width="50", bg="#003e94", fg="white", command=blaview).pack(fill='x')
        elif sh == 1 :
            malco += 2
            tez.config(bg="#ffb6c1")
            print('====')
            print('Programs that Request Single Libraries are most Likely Hiding something.')
        


        # Checks if there are any errors generated by PE File, adding on to the final verdict score if any are found as well as displaying them to the user.
        war = pe.get_warnings()

        if not war:
            pass
        else:
            label_filer6 = Label(quickgui, text = "Warnings: ", width="50", bg="#003e94", fg="white")
            label_filer6.pack(fill='x')
            tey = Text(quickgui, width='90', height="4", bg='#ffb6c1' )
            tey.pack()
            old_stdout = sys.stdout    
            sys.stdout = Redirect(tey)
            for x in war:
                print(x)
            malco += 1

        #Allowing the user to View the full PE report by initiating the dosvie function using the following button.

        dosboot = Button(quickgui, text = "View Full PE Report", width="50", bg="#003e94", fg="white", command=dosvie).pack(fill='x')



    # if the program is not an executable, these steps are skipped saving time.
    else:
        tez = Text(quickgui, width='90', height="1")
        tez.pack()
        old_stdout = sys.stdout    
        sys.stdout = Redirect(tez)
        print('this is not an executable file')

        

    #---------------------- Final Verdict -------------------------
    # The Function That determins the final Verdict by collecting all verdict points and checking the sum, the higher sum resulting in the file being classified as malicious. 
    label_filer7 = Label(quickgui, text = "Final Verdict: " , width="50", bg="#003e94", fg="white")
    label_filer7.pack(fill='x')

    ten = Text(quickgui, width='90', height="1")
    ten.pack()

    if malco <= 1:
        ty = ('program Is Most Likely Safe: {} / 7'.format(malco))
        ten.config(bg="#DAF7A6")
    elif malco > 1 and malco <= 4:
        ty = ('potentially Unwanted Program: {} / 7'.format(malco))
        ten.config(bg="#f6b26b")
    else:
        ty = ('Program Is Most Likely Unsafe: {} / 7'.format(malco))
        ten.config(bg="#ffb6c1")
    
    ten.insert('end', ty)

    quickgui.mainloop()

#---------------------- full binary -------------------------
# The main Function that initiates a new window displaying the Full generated Binary translation

def binvie():
    Hexor(filename)
    binner = Tk()
    
    binner.title("Binary Viewer")

    binner.grid_columnconfigure(0, weight=1)
    binner.grid_rowconfigure(0, weight=1)
    
    text = Text(binner, width='80', height="50")
    text.grid(row=0, column=0)

    scrollbar = ttk.Scrollbar(binner, orient='vertical', command=text.yview)
    scrollbar.grid(row=0, column=1, sticky='ns')

    old_stdout = sys.stdout    
    sys.stdout = Redirect(text)
    global hex_arra
    global clean_arra
    print('binary viewer:', filename, '\n')
    for i in range(0, len(clean_arra), 15):
        print(*hex_arra[i:i+15], ' | ', *clean_arra[i:i+15])

    print('\n')

    text['yscrollcommand'] = scrollbar.set
    binner.mainloop()


#---------------------- full Blacklist -------------------------
# The main Function that initiates a new window displaying the full list of blacklisted functions found when analyzing the file
def blaview():
    global greylist
    binner = Tk()
    
    binner.title("BlackListed Functions Found")

    binner.grid_columnconfigure(0, weight=1)
    binner.grid_rowconfigure(0, weight=1)
    
    text = Text(binner, width='60', height="30")
    text.grid(row=0, column=0)

    scrollbar = ttk.Scrollbar(binner, orient='vertical', command=text.yview)
    scrollbar.grid(row=0, column=1, sticky='ns')

    old_stdout = sys.stdout    
    sys.stdout = Redirect(text)
    print('Are you sure the program needs to use these functions? \n')
    
    for entry in greylist:
        print(entry)
        for imp in greylist[entry]:
            print('\t', imp)

    text['yscrollcommand'] = scrollbar.set
    binner.mainloop()

#---------------------- full PE VIEW -------------------------
# The main Function that initiates a new window displaying the report generated by PEfile

def dosvie():
    dosser = Tk()
    
    dosser.title("PE Viewer")
    
    text = Text(dosser, width='100', height="50")
    text.grid(row=0, column=0)

    scrollbar = ttk.Scrollbar(dosser, orient='vertical', command=text.yview)
    scrollbar.grid(row=0, column=1, sticky='ns')

    old_stdout = sys.stdout    
    sys.stdout = Redirect(text)
    try:
        pe =  pefile.PE(filename)
        print(str(pe))
    except:
        print('this is not an executable file')

    text['yscrollcommand'] = scrollbar.set
    dosser.mainloop()

#------------------------- start -----------------------
filez = '2222.jpg'
main_Gui()


